/*
 * DSVP — Dead Simple Video Player
 * subtitle.c — Subtitle stream detection, decoding, and rendering
 *
 * Handles:
 *   - Cataloging available subtitle tracks in a container
 *   - Opening/closing subtitle codecs
 *   - Decoding text subtitles (SRT, ASS/SSA)
 *   - Rendering with SDL_ttf: golden yellow (#FFDF00) + black outline
 *   - Track cycling with 'S' key (including "Off" option)
 */

#include "dsvp.h"

/* ── Font state (module-level) ─────────────────────────────────────── */

static TTF_Font *sub_font         = NULL;
static TTF_Font *sub_font_outline = NULL;
static int       font_loaded      = 0;

/* Golden Yellow subtitle color and black outline */
static const SDL_Color COLOR_SUB     = { 255, 223, 0, 255 };   /* #FFDF00 */
static const SDL_Color COLOR_OUTLINE = { 0,   0,   0, 255 };

/* ── Font discovery ────────────────────────────────────────────────── */

static const char *find_system_font(void) {
    static const char *candidates[] = {
#ifdef _WIN32
        "C:\\Windows\\Fonts\\verdana.ttf",
        "C:\\Windows\\Fonts\\arial.ttf",
        "C:\\Windows\\Fonts\\tahoma.ttf",
        "C:\\Windows\\Fonts\\segoeui.ttf",
#elif defined(__APPLE__)
        "/System/Library/Fonts/Supplemental/Verdana.ttf",
        "/System/Library/Fonts/Helvetica.ttc",
        "/Library/Fonts/Arial.ttf",
#else
        "/usr/share/fonts/truetype/msttcorefonts/Verdana.ttf",
        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "/usr/share/fonts/TTF/DejaVuSans.ttf",
        "/usr/share/fonts/dejavu-sans-fonts/DejaVuSans.ttf",
        "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
        "/usr/share/fonts/liberation-sans/LiberationSans-Regular.ttf",
        "/usr/share/fonts/truetype/freefont/FreeSans.ttf",
        "/usr/share/fonts/noto/NotoSans-Regular.ttf",
        "/usr/share/fonts/truetype/noto/NotoSans-Regular.ttf",
        "/usr/share/fonts/google-noto/NotoSans-Regular.ttf",
#endif
        NULL
    };

    for (int i = 0; candidates[i]; i++) {
        FILE *f = fopen(candidates[i], "rb");
        if (f) {
            fclose(f);
            return candidates[i];
        }
    }
    return NULL;
}


/* ═══════════════════════════════════════════════════════════════════
 * Font Init / Close
 * ═══════════════════════════════════════════════════════════════════ */

int sub_init_font(void) {
    if (font_loaded) return 0;

    if (TTF_Init() < 0) {
        log_msg("ERROR: TTF_Init failed: %s", TTF_GetError());
        return -1;
    }

    const char *font_path = find_system_font();
    if (!font_path) {
        log_msg("ERROR: No suitable TTF font found on system");
        log_msg("  Windows: needs Verdana or Arial in C:\\Windows\\Fonts\\");
        log_msg("  Linux: sudo apt install fonts-dejavu-core");
        TTF_Quit();
        return -1;
    }

    int font_size = 32;

    sub_font = TTF_OpenFont(font_path, font_size);
    if (!sub_font) {
        log_msg("ERROR: Cannot open font %s: %s", font_path, TTF_GetError());
        TTF_Quit();
        return -1;
    }

    sub_font_outline = TTF_OpenFont(font_path, font_size);
    if (sub_font_outline) {
        TTF_SetFontOutline(sub_font_outline, 2);
    }

    TTF_SetFontHinting(sub_font, TTF_HINTING_LIGHT);
    if (sub_font_outline)
        TTF_SetFontHinting(sub_font_outline, TTF_HINTING_LIGHT);

    font_loaded = 1;
    log_msg("Subtitle font loaded: %s (%dpt)", font_path, font_size);
    return 0;
}

void sub_close_font(void) {
    if (sub_font)         { TTF_CloseFont(sub_font);         sub_font = NULL; }
    if (sub_font_outline) { TTF_CloseFont(sub_font_outline); sub_font_outline = NULL; }
    if (font_loaded)      { TTF_Quit(); font_loaded = 0; }
}


/* ═══════════════════════════════════════════════════════════════════
 * Stream Discovery
 * ═══════════════════════════════════════════════════════════════════ */

void sub_find_streams(PlayerState *ps) {
    ps->sub_count      = 0;
    ps->sub_selection  = 0;
    ps->sub_active_idx = -1;

    for (unsigned i = 0; i < ps->fmt_ctx->nb_streams && ps->sub_count < MAX_SUB_STREAMS; i++) {
        AVStream *st = ps->fmt_ctx->streams[i];
        if (st->codecpar->codec_type != AVMEDIA_TYPE_SUBTITLE) continue;

        enum AVCodecID cid = st->codecpar->codec_id;
        if (cid != AV_CODEC_ID_SRT &&
            cid != AV_CODEC_ID_SUBRIP &&
            cid != AV_CODEC_ID_ASS &&
            cid != AV_CODEC_ID_SSA &&
            cid != AV_CODEC_ID_MOV_TEXT &&
            cid != AV_CODEC_ID_TEXT &&
            cid != AV_CODEC_ID_WEBVTT) {
            log_msg("Subtitle stream %d: skipping bitmap codec %s", i,
                avcodec_get_name(cid));
            continue;
        }

        int idx = ps->sub_count;
        ps->sub_stream_indices[idx] = (int)i;

        const AVDictionaryEntry *lang  = av_dict_get(st->metadata, "language", NULL, 0);
        const AVDictionaryEntry *title = av_dict_get(st->metadata, "title", NULL, 0);

        if (title && lang) {
            snprintf(ps->sub_stream_names[idx], sizeof(ps->sub_stream_names[idx]),
                "%s (%s)", title->value, lang->value);
        } else if (lang) {
            snprintf(ps->sub_stream_names[idx], sizeof(ps->sub_stream_names[idx]),
                "%s", lang->value);
        } else if (title) {
            snprintf(ps->sub_stream_names[idx], sizeof(ps->sub_stream_names[idx]),
                "%s", title->value);
        } else {
            snprintf(ps->sub_stream_names[idx], sizeof(ps->sub_stream_names[idx]),
                "Track %d", idx + 1);
        }

        log_msg("Subtitle stream %d: [%d] %s (%s)", idx, (int)i,
            ps->sub_stream_names[idx], avcodec_get_name(cid));
        ps->sub_count++;
    }

    log_msg("Found %d text subtitle stream(s)", ps->sub_count);
}


/* ═══════════════════════════════════════════════════════════════════
 * Codec Open / Close
 * ═══════════════════════════════════════════════════════════════════ */

int sub_open_codec(PlayerState *ps, int stream_idx) {
    sub_close_codec(ps);

    if (stream_idx < 0) return 0;

    AVStream *st = ps->fmt_ctx->streams[stream_idx];
    const AVCodec *codec = avcodec_find_decoder(st->codecpar->codec_id);
    if (!codec) {
        log_msg("ERROR: No decoder for subtitle codec %s",
            avcodec_get_name(st->codecpar->codec_id));
        return -1;
    }

    ps->sub_codec_ctx = avcodec_alloc_context3(codec);
    avcodec_parameters_to_context(ps->sub_codec_ctx, st->codecpar);

    int ret = avcodec_open2(ps->sub_codec_ctx, codec, NULL);
    if (ret < 0) {
        log_msg("ERROR: Cannot open subtitle codec: %s", av_err2str(ret));
        avcodec_free_context(&ps->sub_codec_ctx);
        return -1;
    }

    ps->sub_active_idx = stream_idx;
    log_msg("Subtitle codec opened: %s (stream %d)", codec->name, stream_idx);
    return 0;
}

void sub_close_codec(PlayerState *ps) {
    if (ps->sub_codec_ctx) {
        avcodec_free_context(&ps->sub_codec_ctx);
    }
    ps->sub_active_idx = -1;
    ps->sub_valid = 0;
    ps->sub_text[0] = '\0';
}


/* ═══════════════════════════════════════════════════════════════════
 * Track Cycling
 * ═══════════════════════════════════════════════════════════════════
 *
 * No seeking is performed — subtitles appear from the next event
 * in the container. This is standard behavior (VLC, mpv do the same).
 */

void sub_cycle(PlayerState *ps) {
    if (ps->sub_count == 0) {
        snprintf(ps->sub_osd, sizeof(ps->sub_osd), "No subtitles available");
        ps->sub_osd_until = get_time_sec() + 2.0;
        return;
    }

    /* Cycle: 0 (off) → 1 → 2 → ... → N → 0 (off) */
    ps->sub_selection = (ps->sub_selection + 1) % (ps->sub_count + 1);

    if (ps->sub_selection == 0) {
        sub_close_codec(ps);
        snprintf(ps->sub_osd, sizeof(ps->sub_osd), "Subtitles: Off");
        log_msg("Subtitles disabled");
    } else {
        int sel = ps->sub_selection - 1;
        int stream_idx = ps->sub_stream_indices[sel];

        sub_open_codec(ps, stream_idx);

        /* Clear current display so new track takes effect immediately */
        ps->sub_valid = 0;
        ps->sub_text[0] = '\0';

        snprintf(ps->sub_osd, sizeof(ps->sub_osd), "Subtitles: %s",
            ps->sub_stream_names[sel]);
        log_msg("Subtitles: %s (stream %d)",
            ps->sub_stream_names[sel], stream_idx);
    }

    ps->sub_osd_until = get_time_sec() + 2.0;
}


/* ═══════════════════════════════════════════════════════════════════
 * ASS Markup Stripping
 * ═══════════════════════════════════════════════════════════════════ */

static void strip_ass_markup(const char *ass_event, char *out, int out_size) {
    const char *p = ass_event;
    int commas = 0;
    while (*p && commas < 8) {
        if (*p == ',') commas++;
        p++;
    }

    if (commas < 8) p = ass_event;

    int o = 0;
    while (*p && o < out_size - 1) {
        if (*p == '{') {
            while (*p && *p != '}') p++;
            if (*p == '}') p++;
            continue;
        }
        if (*p == '\\' && (*(p + 1) == 'N' || *(p + 1) == 'n')) {
            if (o < out_size - 1) out[o++] = '\n';
            p += 2;
            continue;
        }
        out[o++] = *p++;
    }
    out[o] = '\0';

    while (o > 0 && (out[o - 1] == ' ' || out[o - 1] == '\n' || out[o - 1] == '\r')) {
        out[--o] = '\0';
    }
    char *start = out;
    while (*start == ' ' || *start == '\n' || *start == '\r') start++;
    if (start != out) memmove(out, start, strlen(start) + 1);
}


/* ═══════════════════════════════════════════════════════════════════
 * Subtitle Decoding
 * ═══════════════════════════════════════════════════════════════════
 *
 * Called from the main thread each frame. Pops ONE subtitle at a
 * time from the queue and holds it until its display time expires.
 * Skips subtitles whose end time has already passed.
 */

void sub_decode_pending(PlayerState *ps) {
    if (ps->sub_active_idx < 0 || !ps->sub_codec_ctx) return;
    if (ps->sub_selection <= 0 || ps->sub_selection > ps->sub_count) return;

    /* Get the queue for the active subtitle stream */
    int queue_idx = ps->sub_selection - 1;
    PacketQueue *spq = &ps->sub_pqs[queue_idx];

    double now = ps->audio_clock;
    if (ps->audio_stream_idx < 0) now = ps->video_clock;

    /* If current subtitle is still valid and on-screen, keep it */
    if (ps->sub_valid && now <= ps->sub_end_pts) return;

    /* Current subtitle expired (or none active) — try the next one */
    ps->sub_valid = 0;

    AVPacket pkt;
    while (pq_get(spq, &pkt, 0) > 0) {
        AVSubtitle sub;
        int got_sub = 0;

        int ret = avcodec_decode_subtitle2(ps->sub_codec_ctx, &sub, &got_sub, &pkt);
        if (ret < 0 || !got_sub) {
            log_msg("Sub: decode failed ret=%d got=%d", ret, got_sub);
            av_packet_unref(&pkt);
            continue;
        }

        /* Compute display timing */
        AVStream *st = ps->fmt_ctx->streams[ps->sub_active_idx];
        double pkt_pts = 0.0;
        if (pkt.pts != AV_NOPTS_VALUE) {
            pkt_pts = (double)pkt.pts * av_q2d(st->time_base);
        }

        double start = pkt_pts + (double)sub.start_display_time / 1000.0;
        double end   = pkt_pts + (double)sub.end_display_time / 1000.0;

        /* SRT/subrip decoded by FFmpeg often sets end_display_time=0.
         * The actual duration is in pkt.duration in stream time_base. */
        if (sub.end_display_time == 0 && pkt.duration > 0) {
            end = pkt_pts + (double)pkt.duration * av_q2d(st->time_base);
        } else if (sub.end_display_time == 0) {
            end = start + 3.0;  /* last resort fallback */
        }

        /* Extract text */
        char text[SUB_TEXT_SIZE] = {0};
        for (unsigned i = 0; i < sub.num_rects; i++) {
            AVSubtitleRect *rect = sub.rects[i];
            if (rect->type == SUBTITLE_TEXT && rect->text) {
                snprintf(text, sizeof(text), "%s", rect->text);
                log_msg("Sub [TEXT] %.1f-%.1f: \"%.*s\"", start, end, 60, text);
            } else if (rect->type == SUBTITLE_ASS && rect->ass) {
                strip_ass_markup(rect->ass, text, sizeof(text));
                log_msg("Sub [ASS] %.1f-%.1f: \"%.*s\"", start, end, 60, text);
            } else {
                log_msg("Sub: unknown rect type %d", rect->type);
            }
        }

        if (sub.num_rects == 0) {
            log_msg("Sub: packet decoded but 0 rects (pts=%.1f)", pkt_pts);
        }

        avsubtitle_free(&sub);
        av_packet_unref(&pkt);

        if (text[0] == '\0') continue;

        /* Skip subtitles that have already expired */
        if (end < now) {
            log_msg("Sub: skipped expired (end=%.1f < now=%.1f)", end, now);
            continue;
        }

        /* Keep this subtitle */
        snprintf(ps->sub_text, sizeof(ps->sub_text), "%s", text);
        ps->sub_start_pts = start;
        ps->sub_end_pts   = end;
        ps->sub_valid     = 1;
        break;  /* Show this one, leave rest in queue for later */
    }
}


/* ═══════════════════════════════════════════════════════════════════
 * Subtitle Rendering
 * ═══════════════════════════════════════════════════════════════════ */

static void render_text_outlined(SDL_Renderer *renderer, TTF_Font *font,
                                  TTF_Font *outline_font, const char *text,
                                  int x, int y, SDL_Color fg, SDL_Color outline_col) {
    if (!text || !text[0]) return;

    if (outline_font) {
        SDL_Surface *outline_surf = TTF_RenderUTF8_Blended(outline_font, text, outline_col);
        if (outline_surf) {
            SDL_Texture *outline_tex = SDL_CreateTextureFromSurface(renderer, outline_surf);
            if (outline_tex) {
                int outline_offset = TTF_GetFontOutline(outline_font);
                SDL_Rect dst = { x - outline_offset, y - outline_offset,
                                 outline_surf->w, outline_surf->h };
                SDL_RenderCopy(renderer, outline_tex, NULL, &dst);
                SDL_DestroyTexture(outline_tex);
            }
            SDL_FreeSurface(outline_surf);
        }
    }

    SDL_Surface *text_surf = TTF_RenderUTF8_Blended(font, text, fg);
    if (text_surf) {
        SDL_Texture *text_tex = SDL_CreateTextureFromSurface(renderer, text_surf);
        if (text_tex) {
            SDL_Rect dst = { x, y, text_surf->w, text_surf->h };
            SDL_RenderCopy(renderer, text_tex, NULL, &dst);
            SDL_DestroyTexture(text_tex);
        }
        SDL_FreeSurface(text_surf);
    }
}

void sub_render(PlayerState *ps, SDL_Renderer *renderer, int win_w, int win_h) {
    if (!font_loaded) return;

    /* ── Render active subtitle text ── */
    if (ps->sub_valid && ps->sub_text[0]) {
        double now = ps->audio_clock;
        if (ps->audio_stream_idx < 0) now = ps->video_clock;

        if (now >= ps->sub_start_pts && now <= ps->sub_end_pts) {
            char buf[SUB_TEXT_SIZE];
            snprintf(buf, sizeof(buf), "%s", ps->sub_text);

            char *lines[64];
            int nlines = 0;
            char *tok = strtok(buf, "\n");
            while (tok && nlines < 64) {
                if (tok[0] != '\0') {
                    lines[nlines++] = tok;
                }
                tok = strtok(NULL, "\n");
            }

            int font_size = win_h / 24;
            if (font_size < 14) font_size = 14;
            if (font_size > 54) font_size = 54;

            TTF_SetFontSize(sub_font, font_size);
            if (sub_font_outline)
                TTF_SetFontSize(sub_font_outline, font_size);

            int line_height = TTF_FontLineSkip(sub_font);
            int total_height = nlines * line_height;
            int y_base = win_h - 60 - total_height;

            for (int i = 0; i < nlines; i++) {
                int tw = 0, th = 0;
                TTF_SizeUTF8(sub_font, lines[i], &tw, &th);
                int x = (win_w - tw) / 2;
                int y = y_base + i * line_height;

                render_text_outlined(renderer, sub_font, sub_font_outline,
                    lines[i], x, y, COLOR_SUB, COLOR_OUTLINE);
            }
        } else if (now > ps->sub_end_pts) {
            ps->sub_valid = 0;
        }
    }

    /* ── Render track-change OSD (subtitle or audio) ── */
    const char *osd_text = NULL;
    double osd_until = 0;

    /* Audio OSD takes priority if both are active */
    if (ps->aud_osd[0] && get_time_sec() < ps->aud_osd_until) {
        osd_text = ps->aud_osd;
        osd_until = ps->aud_osd_until;
    } else if (ps->aud_osd[0]) {
        ps->aud_osd[0] = '\0';
    }

    if (ps->sub_osd[0] && get_time_sec() < ps->sub_osd_until) {
        /* If no audio OSD, show subtitle OSD; otherwise audio wins */
        if (!osd_text) {
            osd_text = ps->sub_osd;
            osd_until = ps->sub_osd_until;
        }
    } else if (ps->sub_osd[0]) {
        ps->sub_osd[0] = '\0';
    }

    if (osd_text && get_time_sec() < osd_until) {
        int font_size = win_h / 40;
        if (font_size < 12) font_size = 12;
        if (font_size > 32) font_size = 32;

        TTF_SetFontSize(sub_font, font_size);
        if (sub_font_outline)
            TTF_SetFontSize(sub_font_outline, font_size);

        int tw = 0, th = 0;
        TTF_SizeUTF8(sub_font, osd_text, &tw, &th);
        int x = (win_w - tw) / 2;
        int y = 30;

        render_text_outlined(renderer, sub_font, sub_font_outline,
            osd_text, x, y, COLOR_SUB, COLOR_OUTLINE);
    }
}
